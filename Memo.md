# 자바 프로그래밍 입문

## 자바 기초
자바는 플랫폼에 종속되지 않는 프로그램을 개발할 수 있음
자바에서 프로그램을 컴파일하면 class 파일이 생성되는데, 이 class 파일은 바이트 코드로 중간 기계어임
그래서 각 운영체제에 맞는 자바 가상 머신(JVM; Java Virtual Machine)을 사용하여, 운영체제에 상관없이 코드를 돌릴 수 있음

자바 소스 코드(Example.java) -> JIT 자바 컴파일러 -> 바이트 코드(Example.class) -> JVM -> 실행

그래서 각 운영체제에 맞는 자바 실행 환경(JRE; Java Runtime Environment)를 설치하면, 자바 가상 머신을 설치할 수 있음

자바에서는 자바 개발 키트(JDK; Java Development Kit)를 제공함
이는 기본 기능을 제공하는 클래스 뿐 아니라 자료 구조, 네트워크, 입출력, 예외 처리 등에 최적화된 알고리즘 라이브러리를 제공함

## 클래스
클래스는 객체의 속성과 기능을 코드로 구현한 것
```
(접근 제어자) class 클래스 이름 {
	멤버 변수; -> 객체의 속성
	메서드; -> 객체의 기능
}
```

하나의 자바 파일레 하나의 클래스를 두는 것이 원칙이나, 여러 개의 클래스가 같이 있는 경우 public 클래스는 단 하나이며, public 클래스와 자바 파일의 이름은 동일해야 함!
자바의 모든 코드는 class 내부에 위치함
클래스 이름은 모두 대문자로 시작

## 패키지
패키지란 클래스 파일의 묶음
패키지는 계층 구조를 가질 수 있음 -> 프로젝트 전체 소스 코드를 구성하는 계층 구조가 됨 -> 잘 만들어야 유지보수가 편리함
같은 이름의 클래스라도 다른 패키지에 속하면 서로 연관이 없음!
페키지 이름은 모두 소문자로 만듦

## 메서드
메서드는 객체의 기능을 제공하기 위해 클래스 내부에 구현되는 함수
메서드 이름은 해당 클래스를 사용하는 코드의 입장에서 짓는 것이 좋음
예를 들어, Student 클래스를 사용하는 A 클래스가 있을 때, A 클래스에서 학생 이름을 가져오는 메서드는 getStudentName으로 Student 클래스 안에 구현함
변수와 메서드 이름은 낙타 표기법을 사용함
함수가 호출되면 '스택 메모리'에 생성됨
```
int add(int num1, int num2){
	int result;
	result = num1 + num2;
	return result;
}
```

### main()
main() 함수는 자바 가상 머신이 프로그램을 시작하기 위해 호출하는 함수임
클래스 내부에 만들지만, 클래스의 메서드는 아님!
클래스 내부가 아닌, 테스트용 클래스를 따로 만들어 main() 함수를 실행하기도 함
이때 서로 다른 패키지에 있는 클래스를 사용하려면, import문을 사용해 사용하기 원하는 클래스를 불러와야 함. 같은 패키지 안이라면 상관없음!

## 인스턴스
인스턴스는 클래스가 메모리 공간에 생성된 상태임
생성된 클래스의 인스턴스를 객체라고도 함!
클래스의 생성자를 호출하면 인스턴스가 생성되며, 하나의 클래스로부터 여러 개의 인스턴스를 생성할 수 있음

참조 변수를 사용하면 인스턴스의 멤버 변수와 메서드를 참조할 수 있음
   * 	참조 변수.멤버 변수
   * 	참조 변수.메서드
클래스 생성자를 하나 호출하면 인스턴스가 '힙 메모리'에 생성됨 ,
참조 변수는 힙 메모리에 생성된 인스턴스를 가리킴 ,
즉 힙 메모리에 생성된 인스턴스의 메모리 주소는 참조 변수에 저장됨

## 생성자
생성자는 인스턴스를 초기화 할 때의 명령어 집합을 말함
생성자의 이름은 그 클래스의 이름과 같음
생성자는 메서드가 아니기 때문에 상속되지 않으며, 리턴 값은 없음
<modifier><class-name> ([argument_list]){
		[statements]
}
생성자가 없는 클래스는 클래스 파일을 컴파일할 때 자바 컴파일러에서 자동으로 생성자를 만들어줌 = 디폴트 생성자
private 멤버 변수는 외부 클래스에서 값을 지정하지 못하기 때문에, 매개 변수가 있는 생성자를 구현하고 이를 사용하는 것이 편함

## 참조 자료형
참조 자료형은 클래스 자료형으로 선언하는 것을 말함
예를 들어 String은 JDK에서 제공하는 참조 자료형임
참조 자료형은 프로그래머가 필요에 의해 만든 클래스를 사용할 수도 있음

## This 예약어
생성된 인스턴스 스스로를 가리키는 예약어
자신의 메모리를 가리키며, 자신의 주소를 반환
생성자에서 다른 생성자를 호출하는 경우에도 사용

## Static 변수
클래스에서 공통으로 사용할 수 있는 기준 변수
예를 들어, 학생이 입학할 때마다 학번이 순서대로 생성되도록 만들 경우에 사용
`static int serialNum;`
static 변수는 인스턴스가 생성될 때마다 다른 메모리를 가지는 것이 아니라, 프로그램이 메모리에 적재될 때 데이터 영역의 메모리에 생성됨
클래스 변수라고도 함 (멤버 변수는 다른 말로 인스턴스 변수라 함)
따라서 인스턴스의 생성과 관계없이 클래스 이름으로 직접 참조함! ex) `Student.serialNum=100;`
### static 메서드 (=클래스 메서드)
static 변수를 위한 메서드. 예를 들어 정적 변수를 private으로 선언할 때 getter, setter 함수 등이 있음
클래스 메서드 내부에서는 인스턴스 변수를 사용할 수 없음!
인스턴스 변수는 인스턴스가 생성되어야 메모리에 할당되기 때문에 클래스 메서드에서는 사용할 수 없음
클래스 변수는 일반 메서드에서 호출이 가능함

## 변수 정리
- 지역 변수(로컬 변수): 함수 내부에 선언, 함수 내부에서만 사용, '스택'메모리에 저장
- 멤버 변수(인스턴스 변수): 클래스 멤버 변수로 선언, 클래스 내부에서 사용하며 private이 아니면 참조 변수로 다른 클래스에서 사용가능, '힙'메모리에 저장
- static 변수(클래스 변수): static 예약어를 사용하여 클래스 내부에 선언, 클래스 내부에서 사용하고 private이 아니면 클래스 이름으로 다른 클래스에서 사용 가능, 데이터 영역에 저장

## ArrayList 클래스
객체 배열을 관리할 수 있는 멤버 변수와 메서드를 제공함
```
ArrayList<E> 배열 이름 = new ArrayList<E>();
```
### 주요 메서드
- boolean add(E e): 요소 하나를 배열에 추가, E는 요소의 자료형
- int size(): 배열에 추가된 요소 전체 개수 반환
- E get(int index): 배열의 index 위치에 있는 요소 값을 반환
- E remove(int index): 배열의 index 위치에 있는 요소 값을 제거하고 그 값을 반환
- boolean isEmpty(): 배열이 비어 있는지 확인
---
## 상속
클래스를 정의할 때 이미 구현된 클래스를 상속 받아서 속성이나 기능이 확장되는 클래스를 구현함
예를 들어, B클래스가 A클래스를 상속받으면 B클래스는 A클래스의 멤버 변수와 메서드를 사용할 수 있음
is-a 관계일 때 사용하는 것이 가장 효과적임
또한 자바는 다중 상속을 지원하지 않음!
```
class Mammal { // 일반적인 개념 }
class Tiger extends Mammal { }
class Primate extends Mammal { }
class Human extends Primate { // 구체적인 클래스 }
```
하위 클래스에서 상위 클래스 변수를 사용하기 위해서는 `protected` 예약어를 사용
하위 클래스가 생성될 때는 상위 클래스의 생성자가 먼저 호출되기 때문에, 상위 클래스의 멤버 변수가 메모리에 생성되어 하위 클래스에서 접근할 수 있음
모든 하위 클래스는 상위 클래스로 형 변환하여 선언할 수 있음 ex) `Mammal mHuman = new Human(); Primate aHuman = new Human();` / 상위 클래스를 하위 클래스로 선언은 불가!
클래스가 형 변환이 되었을 때는 선언한 클래스형에 기반하여 멤버 변수와 메서드에 접근할 수 있음
### super, 부모를 부르는 예약어
하위 클래스에서 상위 클래스로 접근할 때 사용
하위 클래스는 상위 클래스의 주소, 즉 참조 값을 알고 있는데 이를 super 예약어를 통해 접근할 수 있음 (this랑 비슷하다고 보면 됨)
- 멤버 변수 접근: `super.instanceValue`
- 메서드 접근: `super.method()`
컴파일러가 자동으로 하위 클래스의 디폴트 생성자를 바이트 코드로 변환할 때 `super()`를 추가하여 호출함
만약 디폴트 생성자가 없다면 따로 `super(매개변수)`를 호출해주어야 에러가 나지 않음
### 메서드 오버라이딩
상위 클래스에 정의한 메서드를 하위 클래스에서 재정의할 수 있음
오버라이딩을 하려면 반환형, 메서드 이름, 매개변수 개수, 매개변수 자료형이 반드시 같아야 함
`@Override` 어노테이션을 사용하여 컴파일러에게 명확히 알려주기도 함
### 가상 메서드
상속에서 상위 클래스와 하위 클래스에 같은 이름의 메서드가 존재할 때 호출되는 메서드는 인스턴스에 따라 결정됨
다시 말해 선언한 클래스형이 아닌 생성된 인스턴스의 메서드를 호출함. 이렇게 인스턴스의 메서드가 호출되는 기술을 '가상 메서드'라 함
왜냐하면 멤버 변수는 힙 메모리에 위치하지만 (인스턴스가 생성될 때마다 새로 생성됨) vs. 메서드는 메서드 영역에 위치함 (인스턴스가 달라도 같은 로직임)
따라서 인스턴스가 달라도 동일한 메서드가 호출됨

## 다형성
다형성이란 하나의 코드가 여러 자료형으로 구현되어 실행되는 것을 말함
즉, 상속관계의 서로 다른 클래스 형에 속하는 메서드를 각각 재정의하여, 인스턴스에 맞게 다른 동작을 수행할 수 있음
만약 재정의한 메서드가 가상 메서드 방식에 의해 자동으로 호출되지 않는다면 (즉 다형성이 적용되지 않는다면) if-else if문을 사용하여 각 자료형에 적합한 코드를 따로 구현해야 함
상속과 다형성을 잘 사용하면 간결하고 확장성 있는 프로그램을 구현할 수 있음

## 다운 캐스팅
상위 클래스로 형 변환되었던 하위 클래스를 다시 원래 자료형으로 형 변환하는 것.
상위 클래스로 형 변환되면 하위 클래스에 있는 멤버 변수와 메서드를 사용할 수 없게 됨, 따라서 필요에 따라 다운 캐스팅을 수행함
### instanceof
다운 캐스팅을 하기 전에 상위 클래스로 형 변환된 인스턴스의 원래 자료형을 확인하는 예약어
```
Animal hAnimal = new Human();
if(hAnimal instanceof Human) {
	Human human = (Human)hAnimal;
}
```

## 추상 클래스(abstract class) <-> (concrete class)
추상 클래스는 완전하지 않은 클래스를 말함
중괄호 {}로 감싼 함수의 구현부가 없는 함수를 추상 메서드라고 함 = 선언만 함! `abstract` 예약어 사용
```
abstract int add(int x, int y);
```
함수의 선언부 즉 반환 값, 함수 이름, 매개변수를 정의한다는 것은 곧 함수의 역할이 무엇인지, 어떻게 구현해야 하는지를 정의한다는 뜻임 = 개발 설계과정
상위 클래스에서는 하위 클래스도 공통으로 사용할 메서드를 구현하고, 하위 클래스마다 다르게 구현할 메서드는 추상 메서드로 선언함
추상 메서드가 속하는 클래스는 추상 클래스로 선언해야 함
이탤릭체가 추상 클래스와 메서드를 의미함
*Computer*: *display()*, *typing()*, turnOn(), turnOff()
|--Desktop
|--*Notebook*: typing()
|---|----MyNoteBook
추상 클래스는 인스턴스로 생성할 수 없음!
### 템플릿 메서드
추상 메서드나 구현된 메서드를 활용하여 전체 기능의 흐름(시나리오)을 정의하는 메서드
final로 선언하면 하위 클래스에서 재정의할 수 없음
프레임워크에서 많이 사용되는 설계 패턴 등임, 모든 객체 지향 프로그래밍에서 사용하는 구현 방법임
추상 클래스로 선언된 상위 클래스에 템플릿 메서드를 활용하여 전체적인 흐름을 정의하고 하위 클래스에서 다르게 구현되어야 하는 부분은 추상 메서드로 선언해서 하위 클래스가 구현하도록 함
```
final public void run() {
	startCar();
	drive();
	stop();
	turnOff();
}
```
위와 같이 템플릿 메서드의 역할은 메서드 실행 순서와 시나리오를 정의하는 것임, 템플릿 메서드에서 호출하는 메서드가 추상 메서드라면 차종에 따라 구현 내용이 바뀔 수 있지만, 전체적인 시나리오는 변하지 않음
